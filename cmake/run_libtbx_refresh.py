#!/usr/bin/env python
# coding: utf-8

"""Run a libtbx_refresh.py refresh file.

Usage: runwrap.py --root=<rootpath> --output=<outpath> <file> 

Where:
  --root=<rootpath> The module root
"""
from mock import Mock
import imp
import sys
import os
from docopt import docopt
from types import ModuleType
from pathlib2 import Path, PosixPath
import textwrap

def new_module(name, doc=None):
  m = ModuleType(name, doc)
  m.__file__ = name + '.py'
  sys.modules[name] = m
  return m

def inject_script(module_path, globals):
  path, module_filename = os.path.split(module_path)
  module_name, ext = os.path.splitext(module_filename)
  module = imp.new_module(module_name)
  module.__file__ = module_path
  vars(module).update(globals)
  # f, module.__file__, options = imp.find_module(module_name)
  with open(module_path) as f:
    exec f.read() in vars(module)
  return module

libtbx = new_module("libtbx")
libtbx.utils = new_module("libtbx.utils")
libtbx.forward_compatibility = new_module("libtbx.forward_compatibility")
libtbx.load_env = new_module("libtbx.load_env")
libtbx.str_utils = new_module("libtbx.str_utils")
libtbx.str_utils.show_string = str
libtbx.str_utils.line_breaker = textwrap.fill
libtbx.path = new_module("libtbx.path")

def norm_join(*args):
  return os.path.normpath(os.path.join(*args))
libtbx.path.norm_join = norm_join

def tail_levels(path, number_of_levels):
  return os.path.join(*path.split(os.path.sep)[-number_of_levels:])
libtbx.path.tail_levels = tail_levels

libtbx.utils.warn_if_unexpected_md5_hexdigest = Mock()

def write_this_is_auto_generated(f, file_name_generator):
  print >> f, """\
/* *****************************************************
   THIS IS AN AUTOMATICALLY GENERATED FILE. DO NOT EDIT.
   *****************************************************
   Generated by:
     {}
 */
""".format(file_name_generator)

libtbx.utils.write_this_is_auto_generated = write_this_is_auto_generated


class LibTBXPath(PosixPath):
  __abs__ = lambda x: str(x)


class FakeEnv(object):
  def __init__(self, module_root, output_root):
    self.module_root = module_root
    self.output_root = output_root
    self.build_path = LibTBXPath(output_root)

  def is_ready_for_build(self):
    return True

  def under_dist(self, module_name, path=".", test=os.path.isdir):
    """libtbx method to find a path in an existing module"""
    assert test is os.path.isdir
    module_path = os.path.join(self.module_root, module_name)
    module_path_cctbx = os.path.join(self.module_root, "cctbx_project", module_name)
    if not os.path.isdir(module_path):
      assert os.path.isdir(module_path_cctbx)
      module_path = module_path_cctbx
    path = os.path.normpath(os.path.join(module_path, path))
    print "Returning module path", path
    return path

  def under_build(self, path):
    path = os.path.join(self.output_root, path)
    print "Returning build path", path
    return path

  def find_in_repositories(self, relative_path, return_relocatable_path=False, test=os.path.isdir, optional=None):
    assert test is os.path.isdir
    print "find_in_repositories for ", relative_path
    # return LibTBXPath(self.under_dist(relative_path))
    return self.under_dist(relative_path)

  def dist_path(self, module_path):
    return self.under_dist(module_path)


class RefreshSelf(object):
  remove_obsolete_pyc_if_possible = Mock()

if __name__ == "__main__":
  options = docopt(__doc__)
  source = options["<file>"]
  assert os.path.isdir(options["--root"])
  sys.path.insert(0, os.path.join(options["--root"], "cctbx_project"))
  sys.path.insert(0, options["--root"])
  # assert os.path.isdir(options["--output"])
  if not os.path.isdir(options["--output"]):
    os.makedirs(options["--output"])

  fakeself = RefreshSelf()
  fakeself.env = FakeEnv(options["--root"], options["--output"])
  libtbx.env = fakeself.env
  
  inject_script(source, {"self": fakeself})





